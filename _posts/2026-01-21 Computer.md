---
layout: post
title: "What is SQL"
date: 2026-01-16 00:00:00 +0900
author: kang
categories: [SQL, Fundamental]
tags: [SQL, Python, DataBase, DBMS, RDMS, Overview]
pin: false
math: true
mermaid: true
---

# 
컴퓨터 네가지 핵심부품
CPU
주기억장치 메모리 RAM
보조기억장치 HDD SSD
입출력장치

컴퓨터가 이해하는 정보
1. 데이터
2. 명령어



메인보드 - 마더보드 -> 부품부착


CPU
1.ALU - calcuation
2.제어장치 - 저장장치
3. 레지스터 - 제어신호라는 전기신호를 보내고 명령어를 해석하는 장치

RAM - 실행되고 있는 프로그램 데이터 저장
보조기억장치 - 보관할 프로그램을 저장

메인보드

시스템 버스
1.주소버스
2.데이터버스
3.제어버스

word
CPU가 한번에 처리할수잇는 정보단위
1. half word
2. word
3. double word

binary
16 decmial


character set
encoding
decoding

ASCII
1. 7bit - code point
2. 1bit - parity bit

UNICODE
1. utf-8 - 비트개수 가변
2. utf-16
3. utf-32


컴파일언어
인터프리터 언어
http://godbolt.org/

명령어구조
1.연산코드
2.오퍼랜드 - 연산에 사용될 데이터 (조금) or 연산에 사용될데이터가 저장된 위치(대부분)-> 주소필드
                                        -> 사용가능한 비트가 제한되어있기떄문에

연산코드
1.데이터전송 MOVE STORE LOAD(FETCH) PUSH POP
2.산술논리 연산 ADD SUBTRACT MULTIPLY DIVIDE INCREMENT DECRE  MENT AND OR NOT COMPARE
3.제어흐름 변경 JUMP / CONDITIONAL JUMP/ HALT CALL RETURN
4.입출력 제어

유효주소 (effective address) - 연산에 사용할 데이터가 저장된 위치
명령어 주소 지정방식 (addressing modes)
1. 즉시 주소 지정방식(immediate addressing mode)
2. 직접 주소 지정방식(direct addressing mode)
3. 간접 주소 지정방식(indirect addressing mode)
4. 레지스터 주소 지정방식(regist addressing mode)
5. 레지스터 간접 주소지정방식(regist indirect addressing mode)

C언어 컴파일 과정
1. 전처리기 
    - 외부에 선언된 소스코드 라이브러리
    - 매크로변환
    - 컴파일할 영역 명시
    -> gcc -E file.c -o file.i / vi file.i
2. 컴파일러
    - 어셈블리어로 변환
    -> gcc -S file.i -o file.s / vi file.s 
    -> gcc -S file.c -o file.s / vi file.s
3. 어셈블리
    - 어셈블리어를 기계어로 변환
    - 목적 코드(object file)을 포함한 목적 파일이 됨
    -> gcc -o file.o file.s / xxd file.o | less
4. 링커
    - 목적 코드를 하나로 묶어주는과정


ALU
- 레지스터,제어신호,피연산자,플래그 레지스터, 결과값 레지스터
    - 부호 플래그 , 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그
-제어장치
    - 클럭 : 모든 부분을 움직일 수 있는 시간단위
    - 명령어 레지스터
    - 플레그 레지스터
    - 제어신호 (CPU내부 전달 . 레지스터 ALU)
    - 제어신호 (CPU외부에 전달 . 메모리 입출력장치)

레지스터
    - CPU 내부의 작은 저장장치
    - 프로그램 카운터 - 메모리에서 가져올 명령어 주소(메모리에서 읽어 들일 명령어의 주소)
    - 메모리 주소 레지스터 - 메모리의 주소
    - 메모리 버퍼 레지스터 - 메모리와 주고받을 값(데이터와 명령어)
    - 명령어 레지스터 - 해석할 명령어 (방금 메모리에서 읽어 들인 명령어)

    - 플래그 레지스터 - 연산 결과 또한 CPU상태에 대한 부가적인 정보
    - 범용 레지스터 - 다양하고 일반적인 상황에서 자유롭게 사용
    - 스택 포인터: 스택의 꼭대기를 가리키는 레지스터 
        - 스택 주소 지정 방식: 스택과 스택 포인터를 이용한 주소 지정 방식
    - 베이스 레지스터 - 오퍼랜드 필드의 값(변위) 베이스 레지스터의 값을 더하여 유효주소 얻기
        - 변위 주소 지정 방식: 오퍼랜드 필드의 값(변위) 특정 레지스터의 값을 더하여 유효주소 얻기
        - 상대 주소 지정 방식: 오퍼랜드 필드의 값(변위) 프로그램 카운터 값을 더하여 유효주소 얻기
        - 베이스 레지스터 주소 지정 방식: 오퍼랜드 필드의 값(변위) 베이스 레지스터의 값을 더하여 유효주소 얻기



명령어 사이클
- 인출 - 실행 - 인출 - 실행 (간접주소방식 등으로 인해 간접사이클도 가끔)
- 인터럽트 - CPU가 어서 먼저 처리해야할 작업이 생길때
    - 동기인터럽트 -exception, CPU가 예기치 못한 상황을 접했을때 (폴트 트랩 중단 소프트웨어인터럽트)
    - 비동기 인터럽트 - 입출력 장치에 의해 발생
        - 막을수 있는 인터럽트/막을수 없는 인터럽트
        - 인터럽트 요청신호
        - 언터럽트 플래그 확인 (플래그 레지스터 안에 있음)
        - 인터럽트 서비스 루틴 (인터럽트가 발생했을때 정해진 방식으로 처리하기 위한 프로그램)
        - 인터럽트 벡터 : 각가긔 인터럽트를 구분하기위한 신호
    - 인터럽트할때 지금까지 작업내용을 스택에 백업한다 (프로그램 카운터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 명령어 레지스터 등등)

빠른 CPU 설계
- 클럭신호를 빠르게 / 코어수 늘리기 / 스레드수 늘리기
- 클럭속도 Hz로 측정
- CPU가 하나가 아니라 여러개가 될수 있게되었따
- 코어 수에 비례하여 성능이 증가하지는 않는다
- 하드웨어적 스레드: 하나의 코어가 동시에 처리하는 명령어 단위(논리 프로세서 라고도함)
- 소프트웨어적 스레드: 하나의 프로그램엣 ㅓ독립적으로 실행되는 단위
- 멀티스레드 프로세서의 가장 큰 핵심은 레지스터 -> 레지스터가 명령어위치 등을 가리키기에, 즉 하나의 코어라도 레지스터가 여러개라면 멀티스레드 프로세서가 가능하다는 뜻

명령어 파이프라인
- 명령어 인출
- 명령어 해석
- 명령어 실행
- 결과 저장

파이브라인 위험
- 데이터 위: 명령어 간의 의존성 의해 야기 ( 이전 명령어가 끝나기 전까지 동시에 처리할 수 없는것)
- 제어 위험: 프로그램 카운터의 갑작스러운 변화(JUMP 등)
    -분기 예측(branch prediction)
- 구조적 위험: 서로 다른 명령어가 같은 CPU부품(ALU 레지스터)를 쓰려고할때

슈퍼 스칼라 - CPU내부에 여러개의 명령어 파이프라인을 포함한 구조
-> 파이프라인 위험이 파이프라인 개수가 증가하면 증가함. 즉 비례하여 처리속도가 증가하지않음

비순차적 명령어 처리 - 일부러 순차적으로 안함
- 결과에 영향을 주지않는 실행 흐름을 고려하여 효율적으로 순서를 내부적으로 변경함

명령어 집합 구조(ISA)
-CPU마다 명령어 집합(CPU가 이해할 수 있는 명령어)이 다르다
-명령어가 다르면 해석방식, 레지스터의 종류 개수, 파이프라이닝 용이성 등등이 다름
-CISC
    - 명령어의 형태와 크기가 댜양한 가변 길이 명령어를 활용
    - 상대적으로 적은 수의 명령어로도 프로그램을 실행 가능
    - 메모리를 최대한 아끼며 개발했을 떈 인기가 높았으나 명령어 파이프라이닝이 불리하다
    -실행되기까지 시간이 일정하지않아 하나 실행에 여러 클럭 주기가 필요한경우가있음
-RISC
    - CISC에 비해 짧고 규격화된 명령어를 활용
    - 메모리 접근 최소화(load, store), 레지스터 십분 활용 (범용 레지스터가 많은 경우가 많음)
    - 명령어의 종류가 적어 더 많은 명령어가 필요함
    - 1클럭 내외로 명령어 수행

주기억장치
-RAM 컴퓨터 성능이 영향을 많이 미침
- DRAM 저장된 데이터가 동적으로 사라지는 RAM, 주기적으로 재활성화 해줘야됨(RAM)
- SRAM 저장된 데이터가 정적(사라지지 않는) RAM, DRAM보단 일반적으로 빠름, 소비전력 높고 가격이 높고, 집적도가 낮아, 대용량으로 설계하기 어려움 (일반적으로 캐시메모리)
- SDRAM: DRAM의 발전된 형태, 클럭신호와 동기화된 DRAM, 대역폭(1)
- DDR SDRAM: 발전되 형태의 SDRAM, 대중적인 RAM, 대역폭을 넓혀 속도를 빠르게 만든 SDRAM, 대역폭(2)
- DDR2 SDRAM, 대역폭(4)
- DDR3 SDRAM, 대역폭(8)
- DDR4 SDRAM, 대역폭(16)

- 메모리의 주소 공간 - 물리 주소와 논리주소
    - 물리주소: 메모리 입장에서 바라본 주소, 하드웨어상의 주소
    - 논리주소: CPU와 실행 중인 프로그램 입장에서 본 주소, 프로그램마다 0번지부터 시작하는 주소
    - MMU(메모리 관리 장치) 하드웨어에 의해 변환
        - 논리 주소와 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환
    - 메모리 보호: 다른 프로그램에 메모리에 영역 침범안하게 보호
        - 한계 레지스터 : 논리 주소의 최대 크기를 저장, 프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음
        - CPU는 메모리에 접근하기 전 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지 항상 검사

캐시 메모리
- 저장 장치 계층 구조
    - CPU와 가까운 저장장치는 빠르고, 멀리있는 저장 장치는 느리다
    - 속도가 빠른 저장 장치는 저장 용량이 작고 가격이 비싸다
        - 레지스터, 메모리(RAM), USB 메모리
        - 레지스터 > 캐시메모리 > 메모리 > 보조기억장치
- CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장장치
- 계층적 캐시 메모리
    - L1 > L2 > L3 캐시
    - L1, L2 (코어 내부), L3 코어 외부
-멀티코어 프로세서의 캐시 메모리
    - 서로 다른 L1, L2 캐시가 값을 모를수있으니 sync가 되어야하며, L3를 공유할 수도 있음
    - L1D(data), L1I(instruction)로 분리형 캐시로 나뉘기도함
    - 레지스터 > L1 > L2 > L3 > 주기억장치 > 보조기억장치
- 참조 지역성의 원리
    - 캐시 메모리는 메모리보다 용량이 작아서 메모리의 모든 내용을 저장할 수 없다.
    - CPU가 자주 사용할법한 내용을 예측하여 저장
    - 예측이 들어맞을 경우 캐시 히트(CPU가 캐시 메모리에 저장된 값을 활용할 경우)
    - 예측이 틀렷을 경우 캐시 미스(CPU가 메모리에 접근해야 하는 경우)
    - 캐시 적중률 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수) :: 확인가능한가?
    - 캐시 적중률을 높여야 한다 == CPU가 사용할 법한 데이터를 예측해야한다
    --> CPU가 메모리에 접근할 떄의 주된 경향을 바탕으로 만들어진 원리
        - CPU는 최근 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
        - CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.(공간 지역성)

보조기억장치
-하드디스크 : 자기적인 방식으로 데이터 저장
    - 트랙, 섹터 단위로 저장, 같은 트랙이 모여서 실린더, 연속된 정보는 한 실린더에
    - 탐색시간: 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
    - 회전지연: 헤드가 있는 곳으로 플래터를 이동하는시간
    - 전송시간: 하드디스크와 컴퓨터간에 데이터를 전송하는 시간

-플래시메모리: 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치
    - NAND 플래시 메모리(대부분)
    - NOR 플래시 메모리
    - 셀(cell): 플레시메모리에서 데이터를 저장하는 작은단위
    - 1, 2, 3, 4 (SLC, MLC, TLC, QLC)비트를 젖아할 수 있는 플래시 메모리
    - 한 셀당 (N비트 + 1)^2 만큼 표현 용량 대비 고가격, 비트의 빠른 입출력, 긴 수명 SLC > MLC > TLC
    - 셀이 모여서 MB, GB, TB 저장 장치가 된다
    - 읽고 쓰기는 페이지 단위, 삭제는 블록단위로
    - 셀 -> 페이지 -> 블록 -> 플레인 -> 다이
    - 페이지
        - Free 상태(저장하지않은 상태) / Valid 상태(유효데이터 저장상태) / Invalid 상태(유효하지않은 쓰레기값 저장상태)
    - 가비지 컬렉션
        - 유효한 페이지들만 모아서 새로운 블록으로 복사, 기존의 블록 삭제


RAID
-하드 디스크와 SSD로 사용하는 기술
- 데이터의 안정성 혹은 높은 성능을 위해 여러 물리적 보조기억장치를 마치 하나의 논리적 보조 기억장치처럼 사용하는 기술
- RAID 레벨: RAID구성하는 기술
- RAID 0 :  스트라입(stripe): 마치 줄무늬처럼 분산되어 저장된 데이터
            스트라이핑(striping): 분산하여 저장하는 것
    - 장점: 입출력 향상
    - 단점: 저장된 정보가 안전하진 않음 (하드가 하나 고장나면 파일이 망가져버림 스트라이핑한거라)
- RAID 1 : 미러링 방식, 복사본을 만드는 방식(백업)
- RAID 4 : 완전하 복사본 만드는 대신 패리티 비트를 저장 (패리티를 이용하여 오류 검출 및 복구)
    - 쓸때마다 패리티 디스크의 병목(여러개의 하드디스크 + 1개의 하드디스크를 패리티로 하기때문)
- RAID 5 : 패리티 정보를 하드 디스크마다 패리티를 분산하는 방식 + 한종류의 패리티 
- RAID 5 : 패리티 정보를 하드 디스크마다 패리티를 분산하는 방식 + 패리티를 두종류로 사용함

장치 컨트롤러, 장치 드라이버
- 입출력 장치 정보 주고받는건 쉽지않다
    1. 종류가 너무 많다
    2. 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮다
    - 이런 이유로 장치 컨트롤러를 통해 컴퓨터와 연결한다
        CPU와 입출력장치의 통신중개, 오류 검출, 데이터 버퍼링(서로 다른 전송률 사이에 주고받는 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방식)
- 장치 컨트롤러 구조
    - 버스에 연결되서 데이터 레지스터, 상태 레지스터, 제어 레지스터
    - 하드웨어적 구조
- 장치 드라이버
    - 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램
    - 소프트웨어적 구조

- 세가지 입출력
    - 프로그램 입출력 : 프로그램 속 명령어로 입출력 장치를 제어하는 방법, 장치 컨트롤러와 상호작용, CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어짐
        ex. 하드디스크 백업
            1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령
            2. 하드 디스크 컨트롤러는 하드 디스크 상태 확인 - 상태 레지스터에 준비 완료 표시
            3. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크 준비 여부 확인
            4. 하드 디스크가 준비되었다면 백업할 메모리 정보를 데이터 레지스터에 쓰기
            반복..
        - 메모리 맵 입출력 : 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법, 같은 명령어 사용가능, 메모리 주소공간 축소 -> 왜,, 잘모르겟음
        - 고립형 입출력: (입출력 읽기/쓰기 선을 활성화시키는) 입출력 전용 명령어 사용
    - 인터럽트 기반 입출력
        - 하드웨어 인트럽트는 장치 컨트롤러에 의해 발생
        - 동시다발적인 인터럽트 시
            - 인터럽트 발생 순서대로? - 현실적으로 순차적 안됨, 우선순위가 높은 인터럽트부터
            - PIC로 우선순위를 반영하여 판단 처리 (NMI 우선순위까지는 판단하지않음)
    - DMA 입출력
        - 원래 입출력 장치와 메모리 간의 데이터 이동은 CPU가 주도하고 이동하는 데이터도 반드시 CPU를 거친다 But
        - CPU를 거치지 않고 입출력 장치가 메모리에 직접적으로 접근하는 기능
- 입출력 버스 : 장치컨트롤러들이 시스템버스에 직접연결되면 DMA이 시스템버스를 두번이용하게되고 시스템 버스는 공용자원, 그래서 입출력 버스로 시스템 버스의 이용빈도를 낮추기



-------------------------
운영체제
- 리소스, 시스템 자원: 프로그램 실행에 있어서 필요한 요소
- 커널영역에 적재되어있고, 일반적 프로그램들은 사용자 영역에 적재됨
- 운영체제가 메모리를 관리함, 삭제, 할당 등등
- CPU가 어느 프로그램을 우선순위, 점유율을 줄지 등등을 운영체제가 관리
- 입출력장치 순서도 관리
- 컴퓨터의 자원들을 관리 (CPU, 프로세스, 파일 시스템, 메모리 등등)
- 운영체제가 없으면 하드웨어에 직접 접근해야됨, 운영체제가 있으니 운영체제의 코드를 호출하는 것임.

```cpp
//ATmega
#define DDRA  (*(volatile unsigned char*)0x3A)
#define PORTA (*(volatile unsigned char*)0x3B)

int main(void)
{
    DDRA = 0x01;     // PA0 핀을 출력으로 설정
    PORTA = 0x01;    // PA0 핀에 HIGH → LED ON

    while (1) {
        // 무한 루프 (OS가 없으니 종료 개념 없음)
    }
}
```

커널
- 운영체제의 핵심 서비스(자원 접근,조작, 프로그램 정상 실행 기능 등)를 담당하는 부분

유저 인터페이스(UI) : 그래픽 유저 인터페이스, 커맨더 라인 인터페이스

운영체제의 서비스 종류
시스템 콜과 이중모드
- 일반적인 응용 프로그램이 자원에 직접 접근이 불가능
- 운영체제가 응용 프로그램에서 요청받아서 원하는 자원에 접근

이중모드
-CPU가 명령어를 실행하는 모드를 크게 사용자모드와 커널모드로 구분
    - 사용자모드 : 운영체제 서비스를 제공받을 수 없는 실행 모드, 커널 영역의 코드를 실행할 수 없는 실행모드, 즉 자원 접근불가
    - 커널모드 : 운영체제의 서비스를 제공받을 수 있는 실행모드, 자원 접근을 비롯한 모든 명령어 실행 가능
    - 플래그 레지스터의 슈퍼바이저 플래그가 0, 1,로 사용자모드/커널모드 관리한다

시스템 호출
- 커널 모드로 전환하여 실행하기 위한 호출, 일종의 소프트웨어 인터럽트

운영체제의 핵심 서비스
1. 프로세스 관리
    - 동시에 실행되고 있는 많은 프로세스를 관리
2. 자원 접근 및 할당
    - CPU 스케줄링, 메모리(페이징, 스와핑 등), 입출력장치
3. 파일 시스템 관리
    - 정보를 파일이라는 단위로 저장 장치에 보관, 파일들을 묶어서 폴도 단위로 저장 장치에 보관

프로세스
-포그라운드 프로세스: 사용자가 볼 수 있는공간에서 실행되는 프로세스
-백그라운드 프로세스: 사용자가 볼 수 없는공간에서 실행되는 프로세스
    - 사용자와 직접 상호작용이 가능한 프로세스(데몬, 서비스)
    - 사용자와 직접 상호작용이 가능하지않은 프로세스
-모든 프로세스는 CPU가 필요하다, 프로세스들은 돌아가며 한정된 시간만큼 CPU를 이용한다 -> 타이머 인터럽트 발생으로 시간이 종료됨을 알림
-프로세스 제어 블록(커널영역에 보관되어있음)
    - 빠르게 번갈아 수행되는 프로세스 관리를 위해 사용되는 자료구조가 프로세스 제어블록(PCB)
    - 프로세스 ID(PID): 특정 프로세스 식별을 위해 부여된 고유한 번호
    - 레지스터 값: 실행 차례가 오면 복원해야됨, 프로그램 카운터, 스택포인터
    - 프로세스 상태: 여러 상태들이 PCV에 담김
        - 프로세스의 상태를 PCB에 저장하여 관리한다
        - 생성 상태: 이제 막 메모리에 적재되어 PCB를 할당 받은 상태, 준비 완료시 준비 상태로
        - 준비 상태: 당장이라도 CPU할당받아 실행은 가능, 하지만 자기 상태가 아니라 대기중, 자기차례가되면 실행상태로(디스패치 라고함)
        - 실행 상태: CPU를 할당 받아 실행 중인 상태, 할당 시간을 모두 사용 시(타이머 인터럽트 발생 시) 준비 상태로, 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로
        - 대기 상태: 프로세스가 실행 도중 입출력장치를 사용하는 경우, 입출력 작업은 CPU에 비해 느리기에 대기 상태로, 입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) 준비 상태로
        - 종료 상태: 프로세스가 종료된 상태, PCB폐기, 프로세스의 메모리 영역 정리

    - CPU 스케줄링 정보: 어떤순서로 CPU를 할당받을지
    - 메모리 정보: 어느 주소에 저장되어있는지 대한 정보, 페이지 테이블 정보
    - 사용한 파일과 입출력 장치 정보: 할당된 입출력장치, 사용 중인 파일 정보
-문맥 교환(context switch)
    - 한 프로세스에서 다른 프로세스로 실행 순서로 넘어가려면 
    - 기존 A는 지금까지 정보(context)를 백업
        - 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 사용한 입출력장치 등
        - 다음 차례가 왔을 때 실행을 재개하기 위한 정보
    - 이어 실행할 프로세스 B의 PCB로부터 문맥을 복구
    - 기존 실행 중인 프로세스 문맥을 백업, 새로운 프로세스 실행을 위해 문맥을 복구하는 과정
-사용자 영역 저장된 상태
    - 특정 영역을 나눠서 저장된다
    - 코드영역(텍스트 영역), 데이터 영역, 힙 영역, 스택 영역 등
    - 코드영역: 기계어로 이루어진 명령어 저장, 데이터가 아니라 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 구역(read-only)
    - 데이터 영역: 잠깐 썻다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
        - 코드영역, 데이터 영역은 크기가 고정되어있어 코드, 데이터 영역을 묶어서 정적할당 영역이라고도함
    - 힙영역: 프로그래머가 직접 할당할 수 있는 저장공간(Garbage collection, memory leak 등 관련있음)
    - 스택 영역: 데이터가 일시적으로 저장되는 공간
        - 힙영역, 스택 영역은 크기가 고정되어있는 건 아니기에 동적할당 영역이라고도함

- 프로세스 계층 구조
    - 프로세스 실행 도중 (시스템 호출을 통해) 다른 프로세스 생성 가능
    - 새 프로세스를 생성한 프로세스 : 부모 프로세스
    - 부모 프로세스에 의해 생성된 프로세스 : 자식 프로세스
        - 둘은 각기 다른 PID를 가짐(별개의 프로세스), 단 운영체제에 따라 자식 프로세스 PCB에 부모프로세스 PID(PPID)를 명시하기도함
- 프로세스 생성 기법
    - 부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성
        - fork 시스템 호출: 복사본(=자식 프로세스) 생성, 부모 프로세스의 자원 상속
    - 자식 프로세스는 exec 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 교체
        - exec 시스템 호출: 메모리 공간을 새로운 프로그램으로 덮어쓰기, 코드.데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화

스레드
- 프로세스를 구성하는 실행 흐름의 단위, 하나의 프로세스는 하나 이상의 스레드를 가질 수 있다
- 구성요소
    - 스레드 ID, 프로그램 카운터를 비롯한 레지스터값, 스택 등 실행에 필요한 최소한의 정보
    - 프로세스를 이루는 스레드들은 프로세스의 자원을 공유하면서 실행이된다.
        - 동일한 PCB, 공유하는 자원 / 쓰레드마다 따로 가지는 자원이있음
        - 공유 : PCB, 코드, 데이터, 힙, 파일 -> 협력과 통신에 유리
        - 따로가지는 자원 : 레지스터, 스택, 프로그램카운터 -> 때로 문제가 발생

CPU 스케줄링
- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
- 가장 공정하게? -> 차례대로? -> x
- 입출력 작업이 많은 프로세스(=입출력 집중 프로세스)의 우선순위는 CPU 작업이 많은 프로세스(=CPU 집중 프로세스)의 우선순위보다 높다
    - 입출력 작업이 대기에 자주 걸리기때문이다
-PCB에 우선수위가 기록, 프로레스 우선순위 확인 가능 (process explorer에서 확인)
-스케줄링 큐: CPU를 쓰고싶은 프로세스, 하드 디스크를 쓰고 싶은 프로세스, 프린터를 쓰고싶은 프로세스 등 대기한다. (선입선출은 아님 이경우는)
    -준비 큐: CPU를 이용하기위해 기다리는 줄
    -대기 큐: 입출력장치를 이용하기 위해 기다리는 줄
        - 같은 장치를 요구한 프로세스들은 같은 큐에서 대기, 즉 장치별로 따로잇음
    -입출력이 완료되면 대기큐에서 준비큐로 간다
    -선점형/비선점형 스케줄링
        - CPU점유가 급하여 필요할때
        - 선점형 스케줄링: 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수있다. 그만큼 문맥교환에서 오버헤드가 발생할 수 있다.
        - 비선점형 스케줄링: 선점형 스케줄링에 비해 문맥교환에서 발생하는 오버헤드가 적다. 모든 프로세스가 골고루 자원을 이용하기 어렵다.
-CPU 스케줄링 알고리즘
    -선입 선처리 스케줄링
        - FCFS, 비선점형 스케줄링, 단순히 준비 큐에 삽입된 순서대로, 호위효과
    -최단 작업 우선 스케줄링
        -CPU 사용 시간이 짧은 프로세스는 먼저 실행, 호위효과 방지
    -라운드 로빈 스케줄링
        -선입 선처리 스케줄링 + 타임 슬라이스
        - 정해진 타임 슬라이스만큼 시간동안 돌아가며 CPU를 이용하는 선점형 스케줄링, 타임 슬라이스 크기가 중요함
    -최소 잔여 시간 우선 스케줄링
        - 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
        - 정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스 선택
    -우선순위 스케줄링
        -우선순위를 부여하고 우선순위가 높은 프로세스부터 실행,
        -순위가 같으면 선입선처리로 스케줄링
        -기아(starvation)현상, 우선순위 높은것만 주구장창 실행, 우선순위 낮은 프로세스는 영구히 실행연기
        -방지방법:에이징(aging), 오랫동안 대시한 프로세스의 우선순위를 점차 높이는 방식
    -다단계 큐 스케줄링
        -우선순위별로 준비큐를 여러개 사용하는 스케줄링 방식
        -큐간의 이동이 불가능해서 기아현상 발생
    -다단계 피드백 큐 스케줄링
        -큐간의 이동이 가능해짐
        -새롭게 준비상태가된 프로세스가 가장 우선순위로 옮김, 하다가 실행이 더 필요하다면 우선순위가 다음으로 높은 곳으로 삽입, 그리고 또 진행하고 실행이 다 안끝나면 우선순위가 다음으로 높은 큐로 이동
        -낮은 순위큐에 있으면 우선순위는 조금씩 높혀준다. 에이징
    
프로세스 동기화
-실행순서 제어: 프로세스를 올바른 순서대로 실행하기
    - reader writer problem -> 쓰기가 된다음 읽기가 될수잇다
-상호 배제: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기
    - bank account problem -> 한번에 하나의 프로세스만 접근해야하는 자원에 동시 접근을 피하기위한 동기화
    - producer & consumer problem
    - 동시에 접근해서는 안되는 자원에 접근했기떄문에 문제가발생
-공유 자원: 여러 프로세스 혹은 스레드가 공유하는 자원-전역 변수, 파일, 입출력장치, 보조기억장치
-임계 구역: 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역-총합, 잔액 등등의 변수
    -어떤 프로세스가 임계구역에 들어왔다면 다른 프로세스는 시도는하더라도 대기해야한다.
    -레이스 컨디션: 임계 구역에 동시에 접근하면 자원의 일관성이 꺠질 수 있다
-임계구역 문제를 해결하는 세가지 원칙
    1. 상호배제 mutual exculsion: 한 프로세스가 임계구역에 진입했다면 다른 프로세스는 들어올 수 없다.
    2.진행 progress: 임계 구역에 어떤 프로세스도 진입하지 않았따면 진입하고자하는 프로세스는 들어갈 수있어야한다.
    3. 유한 대기 bounded waiting: 한 프로세스가 임계구역에 진입하고싶다면 언젠가는 임계 구역에 들어올 수 있어야 한다. (임계 구역에 들어오기 위해 무한정 대기해서는 안된다)

프로세스 동기화 기법
- 뮤텍스 락
    -상호 배제를 위한 동기화 도구
    -전역변수 lock, 잠그는 역할 acquire함수, 잠금해제 역할 release()
    -lock으로 잠겨있는지 주기적으로 확인 -> lock이 안된상태라면 acquire 동작하고 lock을 true로한다 -> 종료후 release하고 lock을 false로 한다.
    - 바쁜대기(busy waiting) -> while(lock == true); -> 추천하지않음 CPU자원 낭비
- 세마포
    -좀더 일반화된, 공유자원이 여러개있는경우 처리가능
    -전역변수 1개: 사용가능한 공유 자원의 개수 
    -함수 2개: 기다려야 할지 알려주는 wait함수, 기다리는 프로세스에 이제 진행가능하도록 하는 signal함수
    - N개 --> wait call == N-- --> signal call == N++
    - 사용할 개수가 없을때 대기 상태로 만듬, 생겼을때 준비상태로 만듬 (?? 어떻게)
- 모니터
    -모니터에는 하나의 프로세스만 수행 가능
    -상호배제를 위한 동기화
        - 공유자원에 접근하고자 하는 프로세스를 (인터페이스를 위한)큐에 삽입
        - 큐에 삽입된 순서대로 (한 번에 하나의 프로세스만) 공유자원 이용
    -실행 순서 제어를 위한 동기화
        -조건 변수 이용
        -프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
        - wait(): 대기 상태로 변경, 조건 변수에 있는 큐로 삽입
        - signal(): wait()로 대기 상태로 접어든 조건변수를 실행 상태로 변경 
-교착상태(데드락)
    - 서로 자원을 기다리는 상태
    - 발생 조건 파악 가능
        - 어떤 프로세스가 어떤 자원을 할당 받아 사용 중인지 확인 가능
        - 어떤 프로세스가 어떤 자원을 기다리고 있느지 확인 가능
        - 교착상태가 일어날떄는 원의 형태를 띄고있는다
    - 근본적인 발생 이유 : 4개가 모두 만족해야 교착상태 발생함
        1. 상호 배제: 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
        2. 점유와 대기: 자원을 할당 받은 상태에서 다른 자원을 할당 받기를 기다리는 상태
        3. 비선점: 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 상태
        4. 원형 대기: 프로세스들이 원의 형태로 자원ㅇ르 대기하는 상태
- 교착상태 해결 방법 : 예방, 회피, 검출 후 회복
    - 예방 : 근본적인 발생 이유 4가지 중 하나씩 없애기
        - 상호 배제 없애기 : 모든 자원을 공유 -> 불가능
        - 점유와 대기 없애기: 특정 프로세스에 자원을 모두 할당하거나 아예 할당하지 않는 방식으로 배분 -> 자원의 활용률을 낮출 수 있는 방식
        - 비선점 없애기: 선점이 가능한 자원(CPU)에 한해 효과적, 하지만 모든 자원이 선점 가능한 것은 아니다.
        - 원형 대기 조건 없애기: 모든 자원에 번호를 붙이고 오름차순으로 할당하면 원형 대기는 발생하지 않음 -> 동그란걸 일렬로 만드는 형태가 됨
            - 자원에 번호를 붙이는건 어려운작업이며, 어떻게 붙이냐에 따라 다르다
    - 회피 : 무분별한 자원 할당으로 인해 발생했다고 판단
        - 조심 조심 할당, 배분 가능한 자원의 양을 고려하여 교착 상태가 발생하지 않을만큼 자원 배분
        - 안전 순서열 : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
        - 안전 상태 : 교착 상태 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태 (안전 순서열이 있는상태)
        - 불안전 상태: 교착 상태가 발생할 수도 있는 상태 (안전 순서열이 없는상태)
    - 검출 후 회복: 선점을 통한 회복/ 프로세스 강제 종료를 통한 회복
        - 선점을 통한 회복: 교착 상태가 해결될때까지 한 프로셋씩 자원을 몰아주는 방식
        - 프로세스 강제 종료를 통한 회복:
            - 교착 상태에 놓인 프로세스 모두 강제 종료(작업 내용을 잃을 위험)
            - 교착 상태가 해결될때까지 한 프로세스씩 종료(오버헤드)

연속 메모리 상태
-프로세스에 연속적인 메모리 공간을 할당
    -스와핑 : 현재 사용되지 않은 프로세스들을 보조기억장치의 일부 영역으로 쫓아내고 생긴 빈 공간에 새 프로세스를 적재
        - 스왑 인: 보조기억 -> 메모리
        - 스왑 아웃: 메모리 -> 보조기억
        - 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기
-메모리 할당
    - 프로세스는 메모리의 빈공간에 할당되어야한다.
        - 최초적합(first-fit): 운영체제가 메모리 내의 빈공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
            - 검색 최소화, 빠른할당
        - 최적 적합(best-fit): 운영체제가 빈공간을 모두 검색한 뒤, 적재 가능한 가장 작은 공간에 할당
        - 최악 적합(worst-fit): 운영체제가 빈공간을 모두 검색한 뒤, 적재 가능한 가장 큰 공간에 할당
-연속 메모리 할당의 문제점
    -외부 단편화
        - 프로세스들이 실행되고 종료되길 반복하며 메모리 사이 사이에 빈공간이 발생, 이로인해 메모리가 낭비되는 현상
        - 메모리를 연속적으로 할당하는건 매우 비효율적인 방식
    - 물리 메모리보다 큰 프로세스 실행 불가
    -외부 단편화 해결방식
        1. 메모리 압축(compaction)
            - 여기저기 흩어진 빈 공간을 하나로 모아 큰 공간을 만드는 방식
            - 합치는 과정에서 오버헤드가 발생할 수 있음.
        2. 가상 메모리 기법, 페이징

-가상 메모리
    - 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게하는 기술

- 페이징
    - 프로세스가 크기가 다르지만 이를 연속적으로 할당함으로써 문제가 발생했엇음
    - 프로세스를 일정 크기로 자르고 이를 메모리에 불연속적으로 할당할 수 있다면..
    -프로세스의 논리 주소를 공간을 페이지(page)라는 일정 단위로 자르고, 메모리의 물리 주소 공간을 프로엠(frame)이라는 페이지와 동일한 일정한 단위로 자른뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법
    -스와핑 가능, 페이지 인, 페이지 아웃(프로세스 단위에서 페이지단위로 변경됨)
        --> 어떤 프로세스를 실행함에 잇어 모든 페이지가 적재될 필요가 없다는 걸 시사한다. --> 물리메모리보다 큰 프로세스도 실행가능하다.
    - But 프로세스를 이루는 페이지가 연속적으로 되어있지않아 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기 어렵고 CPU가 다음에 실행할 명령어 위치를 찾기 어려워짐
        - 페이지 테이블
            - 실제 메모리 내의 주소인 물리주소에 불연속적으로 배치되더라도 CPU가 바라보는 주소인 논리 주소에는 연속적으로 배치되도록 하는 방법, 페이지 번호와 프레임 번호를 짝지어 주는 일정의 이정표
    - 내부 단편화
        - 페이지가 10KB, 프로세스 크기 108KB -> 내부단편화 2KB
        - 하나의 페이지 크기보다 작은 크기로 발생
    -대형페이지,, 라는것도 있음
    -프로세스마다 페이지 테이블이 있고, 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터(PTBR)가 가리킨다
    - 페이지 테이블이 메모리에 있으면 메모리 접근 시간의 두배로 된다
    - TLB: CPU 곁에 페이지 테이블의 캐시 메모리, 페이지 테이블의 일부를 가져와 저장
        - CPU가 접근하려는 논리 주소가 TLB에 있으면 TLB 히트, 메모리 접근 한번
        - CPU가 접근하려는 논리 주소가 TLB에 없다면 TLB 미스, 메모리 접근 두번
    - 페이징에서의 주소 변환
        -특정 주소에 접근하고자 한다면 어떤 정보가 필요할까
            - 어떤 페이지/프레임에 접근하고 싶은지
            - 접근하려는 주소가 그 페이지 혹은 프레임으로붜 얼마나 떨어져있는지
        -페이징 시스템의 논리주소 : 페이지 번호(page number)와 변위(offset) (사실 더있음, 운영체제마다 차이있음)--> 프레임 번호와 변위도 있는데 변위값은 똑같다
    - 페이지 테이블 엔트리(PTE): 페이지 테이블의 각각의 행
        - 유효 비트: 현재 해당 페이지에 접근 가능한지 유무 (메모리에 적재되어있는지 상태에따라)
            - 값이 0일때 페이지 폴트(page fault)라는 인터럽트 발생해서 페이지 처리 루틴을 통해 원하는 페이지를 메모리로 가져온뒤 1로 만들고 CPU가 접근가능하도록 한다
        - 보호 비트: 페이지 보호 기능을 위해 존재하는 비트
            - 읽기/쓰기/실행 등등에 관계됨 r(1) w(1) x(1)이렇게 여러 비트로 표현하기도함
        - 참조 비트 : CPU가 이 페이지에 접근한 적이 있는지 비트
        - 수정 비트(dirty bit): CPU가 이 페이지에 데이터를 쓴적이 이는지 여부
            - 수정 비트를 확인해서 스왑 아웃될 때 보조기억장치에도 반영해야되기 때문에 이를 바탕으로 덮어쓰기할지 안할지 결정함.
- 페이지 교체와 프레임 할당
    - 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 보내고, 프로세스들에게 적절한 수의 프레임을 할당해야한다
    - 요구 페이징
        - 필요한 페이지만 메모리에 적재하는 방법
        - CPU 가 특정 페이지에 접근하는 명령어를 실행, 해당 페이지가 현재 메모리에 있을(유효비트1)떄 CPU는 페이지가 적재된 프레임에 접근하고 없을땐 페이지 폴트가 발생한다. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다
        - 순수 요구 페이징 : 아무것도 적재안하고 실행필요한거마다 페이지 폴트를 발생해서 할떄마다 적재한다.
        - 요구 페이징 기법으로 적재하다보면 메모리가 찬다. 당장 사용되지않는 적재된 페이지를 보조기억장치로 내보낸다, 이를 결정하는 방식이 페이지 교체 알고리즘
            -페이지 교체 알고리즘
                - 페이지 폴트가 적은 알고리즘 이 좋다.
            -페이지 참조열(page reference string): CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열(연속된건 어차피 페이지 폴트가 발생하지 않기떄문에)
            -FIFO 페이지 교체 알고리즘
                - 가장 단순, 오래된것이 먼저 나간다
                - 실행내내 사용되야될수도있는데 비효율적
            -2차 기회(second-chance) 페이지 교체 알고리즘
                - 참조 비트1:CPU가 한번 참조한 적이 있는 페이지(한번더 기회 + 참조비트 0 변환)
                - 참조 비트0: CPU가가 한번도 참조한적 없는 페이지(내쫓기)
                - 예전에 적재된페이지 + 참조비트 1 -> 참조비트0변환 및 최근에 적재된 페이지로 판단 -> 다른 내쫓을 것 찾기
            -최적 페이지 알고리즘
                - CPU에 의해 참조되는 횟수를 고려
                - 앞으로 사용빈도가 가장 낮은 페이지를 고체하는 알고리즘
                - 가장 낮은 페이지 폴트율을 보장하는 페이지 교체 알고리즘, 실제 구현이 어렵다(미래를 예측해야됨), 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주
            -LRU(Least-Recently-Used) 페이지 교체 알고리즘
                - LRU 페이지 교체 알고리즘: 가장 오래 사용되지 않은 페이지 교체
-스래싱과 프레임 할당
    - 페이지 폴트가 자주 발생하는 이유: 프로세스가 사용할 수 있는 프레임 자체가 적어서 문제
    - 스래싱: 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제
        - 동시에 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는 것은 아니다, 스래싱때문에
        - 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 한다.
        - 정적할당 방식
            - 균등할당(equal allocation)
                - 모든 프로세스들에게 균등하게 프레임을 할당하는 방식(단순,비합리)
            - 비례할당(proportional allocation)
                - 프로세스 크기에 비례하여 프레임 할당(실행과정을 무시한 단순,비합리, 필요로하는 프레임 수는 실행해봐야 안다)
        - 동적 할당 방식
            - 작업 집합 모델
                -프로세스가 실행하는 과정에서 배분할 프레임 결정, CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당된다.
                - 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지
                -작업 집합: 실행 중인 프로세스가 일정시간 동안 참조한 페이지의 집합
                    - 작업집합 구하려면 프로세스가 참조한 페이지, 시간 간격이 필요
            - 페이지 폴트 빈도
                - 페이지 폴트율이 너무 높으면 프로세스는 너무 적은 프레임을 가진다
                - 페이지 폴트율이 너무 낮으면 프로세스는 너무 많은 프레임을 가진다
                - 즉, 전체를 위해 페이지 폴트가 적당히(상하한선의 범위 내에서) 발생해야한다.
- 쓰기시 복사
    - 이론적fork()- -> 프로세스는 기본적으로 자원을 공유하지않는다.
    - 쓰기시 복사 -> 부모 프로세스와 동일한 자식 프로세스가 복제되어 생성되면 자식 프로세스는 부모 프로세스와 동일한 프레임을 가리킴, 쓰기가 없으면 그대로 가지만 만약에 부모/자식 중 하나의 페이지에 쓰기 작업 수행시 해당 페이지는 별도의 공간으로 복제
- 계층적 페이징
    - 프로세스 테이블의 크기는 생각보다 작지않다.
    - 페이지 테이블을 페이징하여 여러 단계의 페이지 페이지를 두는 방식.
    - 그러면 필요한 테이블들만 메모리에 유지하면된다.
    - 계층적 페이징 이용하는 환경에서의 논리주소 
        - 바같페이지 번호, 안쪽페이지 번호, 변위 
    - 계층이 많을수 있지만, 만약에 계층이 많으면 페이지 폴트가 발생할 때 메모리를 많이 참조하여 이를 고려해야한다.

파일과 디렉토리
-보조기억장치에 있는 데이터 덩어리
-파일
    -파일을 실행하기 위한 정보 + 부가 정보(=속성, 메타데이터)
        -속성(운영체제에 따라 다름)
            - 유형: 파일의 종류
                - 실행파일, 목적 파일, 소스 코드 파일, 워드 프로세서 파일, 라이브러리 파일, 멀티미디어 파일, 백업보관 파일
            -크기: 파일의 현재 크기와 허용 가능한최대 크기를 나타낸다
            -보호: 어떤 사용자가 해당 파일을 읽고 쓰고 실행할 수 있는지를 나타낸다.
            -생성 날짜: 파일이 생성된 날짜를 나타낸다
            -마지막 접근 날짜: 파일이 마지막으로 접근한 날짜를 나타낸다
            -마지막 수정 날짜: 파일이 마지막으로 수정된 날짜를 나타낸다
            -생성자: 파일을 생성한 사용자를 나타낸다
            -소유자: 파일을 소유한 사용자를 나타낸다
            -위치 : 파일의 보조기억장치상의 현재 위치를 나타낸다
        - 파일 연산을 위한 시스템 호출: 생성/삭제/열기/닫기/읽기/쓰기 등
-디렉토리
    -윈도우에서는 폴더
    -트리구조 디렉토리: 여러계층으로 파일 및 폴더를 관리
        - 최상위 디렉토리(루트 디렉토리, /, C:\), 서브 디렉토리
    -경로
        -절대 경로(루트 디렉토리에서 자기 자신까지 이르는 경로)/ 상대 경로(현재 디렉토리에서 자기 자신까지 이르는 경로)
    -디렉토리 연산을 위한 시스템 호출: 생성/삭제/열기/닫기/읽기 등
    -디렉토리 엔트리: 해당 디렉토리에 담겨있는 대상과 관련정보가 담긴다 (대상 이름, 저장된 위치(혹은 유추정보))

-파일시스템
    - 파티셔닝: 저장 장치의 논리저깅ㄴ 영역을 구획하는 작업
    - 포매팅: 파일 시스템을 결정, 어떤방식으로 파일관리할지, 새로운 데이터를 쓸 준비 작업
    - 파티션마다 다른 파일시스템(여러 종류가 있음)을 설정할 수 있다.
- 파일 할당 방법
    - 포매팅까지 완료, 운영체제는 파일/디렉토리를 블록 단위로 읽고쓴다. (하나의 파일이 저장될땐 여러블록으로 저장된다.)
    - 파일을 보조기억장치에 할당하는 방법
        -연속할당
            -보조기억장치 내 연속적인 블록에 파일 할당
            -연속된 파일에 접근하려면 첫번째 블록주소와 블록단위길이만 알면된다.
            -디렉터리 엔트리 : 파일이름 & 첫번째 블록주소 & 블록단위길이 명시
            -> 외부단편화 야기할 수 있다.
        -불연속할당
            -연결할당
                - 각 블록의 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당, 연결리스트로 관리
                - 디렉터리 엔트리: 파일이름 & 첫번째 블록 주소 & 블록단위 길이(블록개수),, 다음블록주소도 있어야될꺼같은데
                - 단점: 반드시 첫번쨰 블록부터 하나씩 읽어야한다. 오류 발생시 해당 블록 이후 블록은 접근이 어렵다.
            -색인할당   
                - 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방식
                -파일 내 임의의 위치에 접근하기 용이
                -디렉터리 엔트리: 파일이름& 색인 블록 주소
-파일 시스템
    -FAT 파일 시스템: 연결 할당 기반의 파일 시스템, 연결할당 방식 단점 보완
        -FAT(file Allocation Table)로 관리, 각 블록에 포함된 다음 블록 주소를 한데 모음
        -예약 영역/ FAT영역/ 루트 디렉터리 영역/ 데이터 영역
        -FAT가 메모리에 캐시될 경우 느린 임의 접근 속도 개선가능.
        -디렉터리 엔트리: 파일이름/확장자/속성/예약영역/생성시간/마지막 접근시간/ 마지막 수정시간/ 시작블록/파일크기
    -유닉스 파일 시스템: 색인 할당 기반 파일 시스템, 색인 블록 == i-node
        -파일의 속성정보다 15개의 블록 주소저장 가능
        - i-node를 사용하는 파일 시스템: 예약영역/i-node/데이터 영역
        1. 블록 주소 중 12개에는 직접블록(파일 데이터가 저장된 블록) 주소 저장
        2. 1번으로 충분하지 않다면 13번째 주소에 단일간접블록(파일 데이터를 저장한 블록 주소가 저장된 블록) 주소 저장
        3. 2번으로 충분하지 않다면 14번쨰 주소에 이중간접블록(단일간접블록들의 주소를 저장하는 블록) 주소 저장
        4. 3번으로 충분하지 않다면 15번쨰 주소에 삼중간접블록(이중간접블록들의 주소를 저장하는 블록) 저장
        -루트 디렉토리의 위치는 항상 알도록 되어있따
    -NTFS 파일시스템(WINDOW), EXT 파일시스템(LINUX)
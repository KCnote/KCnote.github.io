---
layout: post
title: "LeetCode 20. Valid Parentheses"
date: 2025-12-10 00:00:00 +0900
author: kang
categories: [leetcode, easy]
tags: [coding test, easy, leetcode]
pin: false
math: true
mermaid: true
---



## ðŸ§© PROBLEM - LeetCode 20. Valid Parentheses
**LINK**: https://leetcode.com/problems/merge-two-sorted-lists/

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

### Example.
[1]

 Input: list1 = [1,2,4], list2 = [1,3,4]
 
 Output: [1,1,2,3,4,4]

###  Constraints:

The number of nodes in both lists is in the range [0, 50].

-100 <= Node.val <= 100

Both are sorted in non-decreasing order.

---


### Problem anaylsis
  1. It is simple merge sort included linked lists
  2. length is 50 x 2, it is very small.


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* listResult = nullptr;

        do
        {
            if (!list1 && !list2)
                break;

            if (!list1)
            {
                listResult = list2;
                break;
            }

            if (!list2)
            {
                listResult = list1;
                break;
            }

            listResult = new ListNode;
            ListNode* listResultCur = listResult;

            ListNode* listCursorL = nullptr;
            ListNode* listCursorH = nullptr;

            while (1)
            {
                if (list1->val >= list2->val)
                {
                    listCursorH = list1;
                    listCursorL = list2;
                }
                else
                {
                    listCursorH = list2;
                    listCursorL = list1;
                }

                listResultCur->val = listCursorL->val;
                listResultCur->next = nullptr;

                if (!listCursorL->next)
                {
                    listResultCur->next = listCursorH;
                    break;
                }

                listResultCur->next = new ListNode;
                listResultCur = listResultCur->next;
                list1 == listCursorL ? list1 = list1->next : list2 = list2->next;
            }
        } while (false);

        return listResult;
    }
};
```


### It is very simple problem. But more focusing to be simple LOW and HIGH list that combined code not seperated.

---
---
### Anaylsis
  - CHECK SCOPE -> INPUT SIZE 
    - Under Hundred: O($2^n$)
    - Under thousand : O($n^2$)
    - Under 10K: O(N $\log{N}$)
    - Under 1M ~ over: O( $\log{n}$)

  - COMPLEXITY
    - Time complexity
    - Space complexity

  - Check Valid DataType
    - Overflow

  - SIMULATION
    - Check test case by myself

  - Compare with other people solutions

---
---


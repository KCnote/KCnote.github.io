---
layout: post
title: "CPU"
date: 2026-01-27 00:00:00 +0900
author: kang
categories: [Computer Structure, Components]
tags: [Computer Structure, Components, CPU]
pin: false
math: true
mermaid: true

---
# ğŸ§  CPU Execution Flow --- A Visual & Intuitive Guide

> A clean, readable, **engineerâ€‘friendly walkthrough** of how a modern
> CPU executes instructions --- from prediction to commit.

![CPU](/assets/img/develop/2026-01-27-CPU.png)

------------------------------------------------------------------------

## ğŸ“Œ At a Glance --- Execution Pipeline

    Predict â†’ Fetch â†’ Decode â†’ Rename â†’ Dispatch â†’ Execute â†’ Writeback â†’ Commit

**Design philosophy:**\
\> ğŸš€ *Speculate far ahead* â†’ âœ… *Commit safely in order*

------------------------------------------------------------------------

# ğŸ PART 1 --- Runtime Execution Flow (Story Mode)

## 1ï¸âƒ£ Instruction Fetch & Branch Prediction

The CPU predicts **where execution will go next** before knowing for
sure.

### ğŸ”® Prediction Engines

  Predictor                Purpose                            Example
  ------------------------ ---------------------------------- -----------
  **BTB**                  Predicts branch target address     if / loop
  **GHB**                  Tracks taken/notâ€‘taken history     T T T T N
  **Indirect Predictor**   Predicts multiâ€‘target jumps        switch
  **Return Stack**         Predicts function return address   return

### ğŸ“¥ Fetch Path

    PC â†’ ITLB â†’ L1 Instruction Cache â†’ Fetch Queue â†’ Decode

â— If wrong â†’ **Flush pipeline & refetch**

------------------------------------------------------------------------

## 2ï¸âƒ£ Decode â†’ Microâ€‘Operations

Instructions become **internal microâ€‘operations (uOps)** describing: -
Execution unit type - Register reads / writes - Memory access - Flag
dependencies

Complex instructions â†’ **multiple uOps**

------------------------------------------------------------------------

## 3ï¸âƒ£ Register Rename --- Removing Fake Dependencies

Renaming maps architectural registers â†’ **physical registers** to
avoid: - WAR - WAW

### ğŸ¯ Result

-   Higher parallelism
-   Fewer stalls
-   ROB entries allocated

------------------------------------------------------------------------

## 4ï¸âƒ£ Dispatch & Outâ€‘ofâ€‘Order Scheduling

uOps wait in execution queues: - Reservation Stations - Issue Queue -
Load / Store Queue

ğŸ“Œ Execution starts **when operands are ready**, not by original order.

------------------------------------------------------------------------

## 5ï¸âƒ£ Execution Units --- Parallel Engines

  Unit                   Role
  ---------------------- --------------------
  ğŸ§® **ALU / Shift**     Integer arithmetic
  âœ– **IMAC / DIV**       Multiply & divide
  ğŸ§¬ **SIMD / Crypto**   Vector & crypto
  ğŸ”€ **Branch Unit**     Flow control
  ğŸ“ **AGU**             Address generation
  ğŸ’¾ **Load / Store**    Memory access

------------------------------------------------------------------------

## 6ï¸âƒ£ Memory Access & Cache Flow

### ğŸ“¤ Load Path

    AGU â†’ DTLB â†’ L1 â†’ L2 â†’ L3 â†’ DRAM

### ğŸ“¥ Store Path

Stores enter **Store Buffer** â†’ visible at commit

### ğŸ“¦ Miss Handling

-   Fill Buffer = incoming cache lines
-   Evict Buffer = outgoing cache lines
-   Dirty â†’ Writeback

------------------------------------------------------------------------

## 7ï¸âƒ£ Multiâ€‘Core Cache Coherency

When cache miss happens: 1. Core becomes **Master** 2. Other cores
snooped 3. Peer cache supplies data OR RAM fetch 4. Fill Buffer â†’ Cache

Protocols: **MESI / MOESI**

------------------------------------------------------------------------

## 8ï¸âƒ£ Writeback

Results written to **Physical Register File (PRF)**\
Dependent instructions wake up

------------------------------------------------------------------------

## 9ï¸âƒ£ Commit --- Making Results Official

âœ” Inâ€‘order architectural update\
âœ” Precise exceptions\
âœ” Correct interrupt timing

> Execution is chaotic --- **commit is disciplined**

------------------------------------------------------------------------

## ğŸ”Ÿ Branch Misprediction Recovery

âŒ Flush wrongâ€‘path instructions\
ğŸ” Restore correct PC\
ğŸš¨ Largest CPU performance penalty

------------------------------------------------------------------------

## 1ï¸âƒ£1ï¸âƒ£ Interrupts, Timers & Debug

  Component     Function
  ------------- --------------------
  ğŸ› **GIC**     Interrupt routing
  â± **Timer**   OS scheduling
  ğŸ§ª **ETM**    Execution trace
  ğŸ”— **CTI**    Debug trigger sync

Interrupts occur at **safe commit points**

------------------------------------------------------------------------

# ğŸ“š PART 2 --- CPU Terminology Glossary (Reference Mode)

## ğŸ”® Branch Prediction

**BTB** --- Branch target cache\
**GHB** --- Branch history tracker\
**Indirect Predictor** --- Multiâ€‘target predictor\
**Return Stack Buffer** --- Predicts return addresses

------------------------------------------------------------------------

## ğŸ§­ Fetch & Address Translation

**PC** --- Next instruction pointer\
**ITLB** --- Virtual â†’ physical instruction translation\
**L1 Iâ€‘Cache** --- Fast instruction cache\
**Instruction Fetch** --- Loads next instruction

------------------------------------------------------------------------

## ğŸ§© Pipeline Stages

**Decode** --- Instruction â†’ uOps\
**Rename** --- Removes false register hazards\
**Dispatch** --- Sends uOps to execution units\
**ROB** --- Tracks inâ€‘flight instructions\
**Commit** --- Makes results architecturally visible

------------------------------------------------------------------------

## âš™ Execution Units

**ALU** --- Integer arithmetic\
**IMAC** --- Multiplyâ€‘accumulate\
**DIV** --- Division\
**CRC** --- Checksum\
**SIMD / ASIMD** --- Vector compute\
**Crypto Unit** --- Cryptography\
**AGU** --- Address calculation\
**DTLB** --- Data address translation

------------------------------------------------------------------------

## ğŸ§± Cache Architecture

**TagRAM** --- Stores cache tags\
**DataRAM** --- Stores cached data\
**L2 Cache** --- Secondary cache\
**Prefetcher** --- Predicts memory access

------------------------------------------------------------------------

## ğŸ” Memory Coherency

**Master** --- Core initiating request\
**Slave** --- Responding cache/memory\
**Snoop** --- Check other caches\
**Fill Buffer** --- Incoming cache storage\
**Evict Buffer** --- Outgoing cache storage\
**ACP** --- Coherent accelerator port

------------------------------------------------------------------------

## ğŸ Debug & Tracing

**ETM** --- Execution tracing hardware\
**CTI** --- Crossâ€‘trigger debugger\
**GIC** --- Interrupt controller\
**Timer** --- Hardware clock

------------------------------------------------------------------------

# ğŸ¯ Why This Guide Works

âœ” Visual, clean, and readable\
âœ” Blogâ€‘ready & portfolioâ€‘ready\
âœ” Interviewâ€‘grade CPU knowledge\
âœ” Designed for longâ€‘term reference

------------------------------------------------------------------------

If you'd like, I can also generate: - ğŸ¨ Matching SVG diagrams - ğŸ§ 
Cycleâ€‘byâ€‘cycle execution visualizations - ğŸ“˜ Advanced CPU Architecture
Series - ğŸ— ARM vs x86 breakdown posts

------------------------------------------------------------------------
